using FS.TimeTracking.Abstractions.Constants;
using FS.TimeTracking.Abstractions.DTOs.Administration;
using FS.TimeTracking.Abstractions.Interfaces.DTOs;
using FS.TimeTracking.Core.Interfaces.Application.Services.Shared;
using FS.TimeTracking.Core.Interfaces.Models;
using FS.TimeTracking.Core.Interfaces.Repository.Services.Database;
using FS.TimeTracking.Core.Models.Configuration;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Options;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Claims;
using System.Threading;
using System.Threading.Tasks;

namespace FS.TimeTracking.Application.Services.Shared;

/// <inheritdoc />
public class AuthorizationService : IAuthorizationService
{
    private readonly IDbRepository _dbRepository;

    /// <summary>
    /// Default user ID taken when authorization feature is disabled.
    /// </summary>
    /// <autogeneratedoc />
    public static readonly Guid DefaultUserId = Guid.Empty;

    /// <summary>
    /// Default username taken when authorization feature is disabled.
    /// </summary>
    /// <autogeneratedoc />
    public static readonly string DefaultUsername = string.Empty;

    /// <inheritdoc />
    public bool AuthorizationDisabled { get; }

    /// <inheritdoc />
    public ClaimsPrincipal CurrentUser { get; }

    /// <inheritdoc />
    public Guid CurrentUserId { get; }

    /// <inheritdoc />
    public bool CanViewForeignData { get; }

    private bool CanManageForeignData { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="AuthorizationService"/> class.
    /// </summary>
    /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
    /// <param name="httpContextAccessor">The HTTP context accessor.</param>
    /// <param name="configuration">The configuration.</param>
    /// <param name="dbRepository">The database repository.</param>
    /// <autogeneratedoc />
    public AuthorizationService(IHttpContextAccessor httpContextAccessor, IOptions<TimeTrackingConfiguration> configuration, IDbRepository dbRepository)
    {
        if (httpContextAccessor.HttpContext == null)
            throw new ArgumentNullException(nameof(httpContextAccessor.HttpContext));

        _dbRepository = dbRepository;

        AuthorizationDisabled = !configuration.Value.Features.Authorization;

        CurrentUser = AuthorizationDisabled
            ? GetDefaultPrincipal()
            : httpContextAccessor.HttpContext.User;

        CurrentUserId = GetUserId(CurrentUser);
        CanViewForeignData = CurrentUser.IsInRole(RoleName.FOREIGN_DATA_VIEW);
        CanManageForeignData = CurrentUser.IsInRole(RoleName.FOREIGN_DATA_MANAGE);
    }

    /// <inheritdoc />
    public bool CanView(Guid userId)
        => AuthorizationDisabled || CanViewForeignData || userId == Guid.Empty || userId == CurrentUserId;

    /// <inheritdoc />
    public bool CanManage(Guid userId)
        => AuthorizationDisabled || CanManageForeignData || userId == Guid.Empty || userId == CurrentUserId;

    /// <inheritdoc />
    public async Task<bool> CanManage<TEntity>(Guid id) where TEntity : class, IIdEntityModel, IUserRelatedModel
    {
        if (AuthorizationDisabled || CanManageForeignData)
            return true;

        var userId = await _dbRepository.FirstOrDefault((TEntity x) => x.UserId, x => x.Id == id);
        return userId == DefaultUserId || userId == CurrentUserId;
    }

    /// <inheritdoc />
    public async Task<bool> CanManage<TDto, TEntity>(TDto dto)
        where TDto : class, IIdEntityDto, IUserRelatedDto
        where TEntity : class, IIdEntityModel, IUserRelatedModel
    {
        if (AuthorizationDisabled || CanManageForeignData)
            return true;

        if (dto.UserId != DefaultUserId && dto.UserId != CurrentUserId)
            return false;

        return await CanManage<TEntity>(dto.Id);
    }

    /// <inheritdoc />
    public async Task SetAuthorizationRelatedProperties<TDto>(TDto entity, CancellationToken cancellationToken = default) where TDto : class, IManageableDto
    {
        var list = new List<TDto>() { entity };
        await SetAuthorizationRelatedProperties(list, cancellationToken);
    }

    /// <inheritdoc />
    public Task SetAuthorizationRelatedProperties<TDto>(List<TDto> entities, CancellationToken cancellationToken = default) where TDto : class, IManageableDto
    {
        var permissionName = PermissionName.FromProtectedDto(typeof(TDto));
        if (permissionName == null)
            throw new InvalidOperationException($"Unable to get permission related to {typeof(TDto).Name}");

        var canManageDto = CurrentUser.IsInRole($"{permissionName}-{PermissionScope.MANAGE}");

        foreach (var entity in entities)
        {
            entity.IsReadonly = entity switch
            {
                UserDto userDto
                    => !canManageDto || (!CanManageForeignData && userDto.Id != CurrentUserId),
                UserGridDto userGridDto
                    => !canManageDto || (!CanManageForeignData && userGridDto.Id != CurrentUserId),
                IUserRelatedDto userRelatedDto
                    => !canManageDto || (!CanManageForeignData && userRelatedDto.UserId != default && userRelatedDto.UserId != CurrentUserId),
                _
                    => !canManageDto
            };
        }

        return Task.CompletedTask;
    }

    private static ClaimsPrincipal GetDefaultPrincipal()
    {
        var claims = new List<Claim>()
        {
            new (ClaimTypes.NameIdentifier, DefaultUserId.ToString()),
            new (ClaimTypes.Name, DefaultUsername),
        };
        var identity = new ClaimsIdentity(claims);
        return new ClaimsPrincipal(identity);
    }

    /// <summary>
    /// Gets the identifier of the user.
    /// </summary>
    /// <exception cref="InvalidOperationException">Thrown when the user has no name identifier.</exception>
    /// <param name="principal">The principal to act on.</param>
    private static Guid GetUserId(ClaimsPrincipal principal)
    {
        var nameIdentifier = principal.Claims.FirstOrDefault(x => x.Type == ClaimTypes.NameIdentifier);
        if (nameIdentifier == null)
            throw new InvalidOperationException("Principal has no name identifier.");
        return Guid.Parse(nameIdentifier.Value);
    }
}