using AutoMapper;
using FS.Keycloak.RestApiClient.Client;
using FS.Keycloak.RestApiClient.Model;
using FS.TimeTracking.Abstractions.DTOs.Administration;
using FS.TimeTracking.Abstractions.Interfaces.DTOs;
using FS.TimeTracking.Application.Services.Shared;
using FS.TimeTracking.Core.Exceptions;
using FS.TimeTracking.Core.Interfaces.Application.Services.Administration;
using FS.TimeTracking.Core.Interfaces.Repository.Services.Administration;
using FS.TimeTracking.Core.Models.Application.Core;
using FS.TimeTracking.Core.Models.Configuration;
using FS.TimeTracking.Core.Models.Filter;
using Microsoft.Extensions.Options;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace FS.TimeTracking.Application.Services.Administration;

/// <inheritdoc />
public class UserService : IUserService
{
    private readonly TimeTrackingConfiguration _configuration;
    private readonly KeycloakConfiguration _keycloakConfiguration;
    private readonly IMapper _mapper;
    private readonly IKeycloakRepository _keycloakRepository;

    /// <summary>
    /// Initializes a new instance of the <see cref="UserService"/> class.
    /// </summary>
    /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
    /// <param name="configuration">The configuration.</param>
    /// <param name="mapper">The mapper.</param>
    /// <param name="keycloakRepository">The keycloak repository.</param>
    /// <autogeneratedoc />
    public UserService(IOptions<TimeTrackingConfiguration> configuration, IMapper mapper, IKeycloakRepository keycloakRepository)
    {
        _configuration = configuration.Value;
        _keycloakConfiguration = _configuration.Keycloak;
        _mapper = mapper;
        _keycloakRepository = keycloakRepository;
    }

    /// <inheritdoc />
    public async Task<UserDto> Get(Guid id, CancellationToken cancellationToken = default)
    {
        var user = await _keycloakRepository.GetUser(_keycloakConfiguration.Realm, id, cancellationToken);
        var client = await _keycloakRepository.GetClients(_keycloakConfiguration.Realm, cancellationToken);
        var clientId = client.Single(x => x.ClientId == _keycloakConfiguration.ClientId).Id;

        var userDto = _mapper.Map<UserDto>(user);

        var userClientRoles = await _keycloakRepository.GetClientRolesOfUser(_keycloakConfiguration.Realm, userDto.Id, clientId, cancellationToken);
        var userClientRoleNames = userClientRoles.Select(x => x.Name).ToList();
        userDto.Permissions = _mapper.Map<List<PermissionDto>>(userClientRoleNames);

        return userDto;
    }

    /// <inheritdoc />
    public async Task<List<UserDto>> GetFiltered(TimeSheetFilterSet filters, CancellationToken cancellationToken = default)
    {
        if (!_configuration.Features.Authorization)
            return new List<UserDto> { new() { Id = AuthorizationService.DefaultUserId, Username = AuthorizationService.DefaultUsername } };

        var users = await _keycloakRepository.GetUsers(_keycloakConfiguration.Realm, cancellationToken: cancellationToken);
        var userDtos = _mapper
            .Map<List<UserDto>>(users)
            .OrderBy(x => !x.Enabled)
            .ThenBy(x => x.Username)
            .ToList();

        var userFilter = filters?.UserFilter.CreateFilter();
        if (userFilter != null)
            userDtos = userDtos.Where(userFilter.Compile()).ToList();

        return userDtos;
    }

    /// <inheritdoc />
    public async Task<List<UserGridDto>> GetGridFiltered(TimeSheetFilterSet filters, CancellationToken cancellationToken = default)
    {
        var users = await GetFiltered(filters, cancellationToken);
        return _mapper.Map<List<UserGridDto>>(users);
    }

    /// <inheritdoc />
    public async Task<UserGridDto> GetGridItem(Guid id, CancellationToken cancellationToken = default)
    {
        var user = await _keycloakRepository.GetUser(_keycloakConfiguration.Realm, id, cancellationToken);
        return _mapper.Map<UserGridDto>(user);
    }

    /// <inheritdoc />
    public async Task<UserDto> Create(UserDto dto)
    {
        var user = _mapper.Map<UserRepresentation>(dto);

        if (!string.IsNullOrEmpty(dto.Password))
            UpdateCredentials(dto, user);

        try
        {
            await _keycloakRepository.CreateUser(_keycloakConfiguration.Realm, user);
        }
        catch (ApiException ex) when (
            ex.Message.Contains("User exists with same username") ||
            ex.Message.Contains("User exists with same email"))
        {
            throw new ConflictException(ApplicationErrorCode.ConflictUserWithSameUsernameExists);
        }

        var keycloakUsers = await _keycloakRepository.GetUsers(_keycloakConfiguration.Realm);
        var keycloakUser = _mapper.Map<UserDto>(keycloakUsers.First(x => x.Username == dto.Username.ToLower()));
        await UpdateUserRoles(keycloakUser.Id, dto);

        return keycloakUser;
    }

    /// <inheritdoc />
    public async Task<UserDto> Update(UserDto dto)
    {
        var keycloakUser = await _keycloakRepository.GetUser(_keycloakConfiguration.Realm, dto.Id);
        _mapper.Map(dto, keycloakUser);

        if (!string.IsNullOrEmpty(dto.Password))
            UpdateCredentials(dto, keycloakUser);

        try
        {
            await _keycloakRepository.UpdateUser(_keycloakConfiguration.Realm, keycloakUser);
        }
        catch (ApiException ex) when (ex.Message.Contains("User exists with same username or email"))
        {
            throw new ConflictException(ApplicationErrorCode.ConflictUserWithSameUsernameExists);
        }

        await UpdateUserRoles(dto.Id, dto);

        var updatedUser = await _keycloakRepository.GetUser(_keycloakConfiguration.Realm, dto.Id);
        return _mapper.Map<UserDto>(updatedUser);
    }

    /// <inheritdoc />
    public async Task<long> Delete(Guid id)
    {
        await _keycloakRepository.DeleteUser(_keycloakConfiguration.Realm, id);
        return 1;
    }

    /// <inheritdoc />
    public async Task SetUserRelatedProperties<T>(T dto, CancellationToken cancellationToken)
        where T : class, IUserRelatedGridDto
    {
        var list = new List<T>() { dto };
        await SetUserRelatedProperties(null, list, cancellationToken);
    }

    /// <inheritdoc />
    public async Task SetUserRelatedProperties<T>(TimeSheetFilterSet filters, List<T> dtos, CancellationToken cancellationToken)
        where T : class, IUserRelatedGridDto
    {
        if (!_configuration.Features.Authorization)
            return;

        var filteredUsers = await GetFiltered(filters, cancellationToken);

        foreach (var dto in dtos)
        {
            var user = filteredUsers.FirstOrDefault(x => x.Id == dto.UserId);
            dto.UserId = user?.Id ?? AuthorizationService.DefaultUserId;
            dto.Username = user?.Username ?? AuthorizationService.DefaultUsername;
        }
    }

    private static void UpdateCredentials(UserDto dto, UserRepresentation keycloakUser)
        => keycloakUser.Credentials = new List<CredentialRepresentation> { new() {
            Type = "password",
            Temporary = true,
            Value = dto.Password,
        } };

    private async Task UpdateUserRoles(Guid userId, UserDto dto)
    {
        var client = await _keycloakRepository.GetClients(_keycloakConfiguration.Realm);
        var clientId = client.Single(x => x.ClientId == _keycloakConfiguration.ClientId).Id;

        var allClientRoles = await _keycloakRepository.GetClientRoles(_keycloakConfiguration.Realm, clientId);
        var userRoleNames = _mapper.Map<List<string>>(dto.Permissions);
        var userRoles = allClientRoles.Where(x => userRoleNames.Contains(x.Name)).ToList();

        await _keycloakRepository.DeleteClientRolesOfUser(_keycloakConfiguration.Realm, userId, clientId, allClientRoles);
        await _keycloakRepository.AddClientRolesToUser(_keycloakConfiguration.Realm, userId, clientId, userRoles);
    }
}