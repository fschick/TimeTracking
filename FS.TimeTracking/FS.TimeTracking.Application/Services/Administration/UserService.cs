using AutoMapper;
using FS.FilterExpressionCreator.Extensions;
using FS.FilterExpressionCreator.Filters;
using FS.Keycloak.RestApiClient.Client;
using FS.Keycloak.RestApiClient.Model;
using FS.TimeTracking.Abstractions.Constants;
using FS.TimeTracking.Abstractions.DTOs.Administration;
using FS.TimeTracking.Abstractions.Interfaces.DTOs;
using FS.TimeTracking.Application.Services.Shared;
using FS.TimeTracking.Core.Exceptions;
using FS.TimeTracking.Core.Interfaces.Application.Services.Administration;
using FS.TimeTracking.Core.Interfaces.Application.Services.Shared;
using FS.TimeTracking.Core.Interfaces.Repository.Services.Administration;
using FS.TimeTracking.Core.Models.Application.Core;
using FS.TimeTracking.Core.Models.Configuration;
using FS.TimeTracking.Core.Models.Filter;
using Microsoft.Extensions.Options;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace FS.TimeTracking.Application.Services.Administration;

/// <inheritdoc />
public class UserService : IUserService
{
    private readonly KeycloakConfiguration _keycloakConfiguration;
    private readonly IMapper _mapper;
    private readonly IKeycloakRepository _keycloakRepository;
    private readonly IAuthorizationService _authorizationService;

    /// <summary>
    /// Initializes a new instance of the <see cref="UserService"/> class.
    /// </summary>
    /// <param name="configuration">The configuration.</param>
    /// <param name="mapper">The mapper.</param>
    /// <param name="keycloakRepository">The keycloak repository.</param>
    /// <param name="authorizationService">The authorization service.</param>
    /// <autogeneratedoc />
    public UserService(IOptions<TimeTrackingConfiguration> configuration, IMapper mapper, IKeycloakRepository keycloakRepository, IAuthorizationService authorizationService)
    {
        _keycloakConfiguration = configuration.Value.Keycloak;
        _mapper = mapper;
        _keycloakRepository = keycloakRepository;
        _authorizationService = authorizationService;
    }

    /// <inheritdoc />
    public async Task<UserDto> Get(Guid id, CancellationToken cancellationToken = default)
    {
        if (_authorizationService.AuthorizationDisabled)
            return new UserDto { Id = AuthorizationService.DefaultUserId, Username = AuthorizationService.DefaultUsername };

        if (!_authorizationService.CanViewUser(id))
            throw new ForbiddenException(ApplicationErrorCode.ForbiddenForeignUserData);

        var user = await _keycloakRepository.GetUser(_keycloakConfiguration.Realm, id, cancellationToken);
        var userDto = _mapper.Map<UserDto>(user);

        var client = await _keycloakRepository.GetClients(_keycloakConfiguration.Realm, cancellationToken);
        var clientId = client.Single(x => x.ClientId == _keycloakConfiguration.ClientId).Id;
        var userClientRoles = await _keycloakRepository.GetClientRolesOfUser(_keycloakConfiguration.Realm, userDto.Id, clientId, cancellationToken);
        var userClientRoleNames = userClientRoles.Select(x => x.Name).ToList();
        userDto.Permissions = _mapper.Map<List<PermissionDto>>(userClientRoleNames);

        await _authorizationService.SetAuthorizationRelatedProperties(userDto, cancellationToken);

        return userDto;
    }

    /// <inheritdoc />
    public async Task<List<UserDto>> GetFiltered(TimeSheetFilterSet filters, CancellationToken cancellationToken = default)
    {
        if (_authorizationService.AuthorizationDisabled)
            return new List<UserDto> { new() { Id = AuthorizationService.DefaultUserId, Username = AuthorizationService.DefaultUsername } };

        var userFilter = filters?.UserFilter ?? new EntityFilter<UserDto>();

        var restrictedToOwnData = !_authorizationService.CanViewForeignData;
        if (restrictedToOwnData)
            userFilter = userFilter.Replace(x => x.Id, _authorizationService.CurrentUserId);

        var users = await _keycloakRepository.GetUsers(_keycloakConfiguration.Realm, cancellationToken: cancellationToken);
        var userDtos = _mapper
            .Map<List<UserDto>>(users)
            .Where(userFilter)
            .OrderBy(x => !x.Enabled)
            .ThenBy(x => x.Username)
            .ToList();

        await _authorizationService.SetAuthorizationRelatedProperties(userDtos, cancellationToken);

        return userDtos;
    }

    /// <inheritdoc />
    public async Task<List<UserGridDto>> GetGridFiltered(TimeSheetFilterSet filters, CancellationToken cancellationToken = default)
    {
        if (_authorizationService.AuthorizationDisabled)
            return new List<UserGridDto>() { new() { Id = AuthorizationService.DefaultUserId, Username = AuthorizationService.DefaultUsername } };

        var users = await GetFiltered(filters, cancellationToken);
        return _mapper.Map<List<UserGridDto>>(users);
    }

    /// <inheritdoc />
    public async Task<UserGridDto> GetGridItem(Guid id, CancellationToken cancellationToken = default)
    {
        if (_authorizationService.AuthorizationDisabled)
            return new UserGridDto { Id = AuthorizationService.DefaultUserId, Username = AuthorizationService.DefaultUsername };

        if (!_authorizationService.CanViewUser(id))
            throw new ForbiddenException(ApplicationErrorCode.ForbiddenForeignUserData);

        var user = await _keycloakRepository.GetUser(_keycloakConfiguration.Realm, id, cancellationToken);
        var userDto = _mapper.Map<UserGridDto>(user);

        await _authorizationService.SetAuthorizationRelatedProperties(userDto, cancellationToken);

        return userDto;
    }

    /// <inheritdoc />
    public async Task<UserDto> Create(UserDto dto)
    {
        if (_authorizationService.AuthorizationDisabled)
            throw new InvalidOperationException("Authorization is disabled");

        if (!_authorizationService.CurrentUser.IsInRole(RoleName.FOREIGN_DATA_MANAGE))
            throw new ForbiddenException(ApplicationErrorCode.ForbiddenForeignUserData);

        var user = _mapper.Map<UserRepresentation>(dto);

        if (!string.IsNullOrEmpty(dto.Password))
            UpdateCredentials(dto, user);

        try
        {
            await _keycloakRepository.CreateUser(_keycloakConfiguration.Realm, user);
        }
        catch (ApiException ex) when (
            ex.Message.Contains("User exists with same username") ||
            ex.Message.Contains("User exists with same email"))
        {
            throw new ConflictException(ApplicationErrorCode.ConflictUserWithSameUsernameExists);
        }

        var keycloakUsers = await _keycloakRepository.GetUsers(_keycloakConfiguration.Realm);
        var keycloakUser = keycloakUsers.First(x => x.Username.Equals(dto.Username, StringComparison.OrdinalIgnoreCase));
        var resultDto = _mapper.Map<UserDto>(keycloakUser);
        await UpdateUserRoles(resultDto.Id, dto);
        await _authorizationService.SetAuthorizationRelatedProperties(resultDto);
        return resultDto;
    }

    /// <inheritdoc />
    public async Task<UserDto> Update(UserDto dto)
    {
        if (_authorizationService.AuthorizationDisabled)
            throw new InvalidOperationException("Authorization is disabled");

        if (!_authorizationService.CanManageUser(dto.Id))
            throw new ForbiddenException(ApplicationErrorCode.ForbiddenForeignUserData);

        var canManageUsers = dto.Permissions.First(x => x.Name == PermissionName.ADMINISTRATION_USERS).Scope == PermissionScope.MANAGE;
        if (dto.Id == _authorizationService.CurrentUserId && !canManageUsers)
            throw new ConflictException(ApplicationErrorCode.ConflictUserNotAllowedToRemoveUserEditPermissionFromItself);

        var keycloakUser = await _keycloakRepository.GetUser(_keycloakConfiguration.Realm, dto.Id);
        _mapper.Map(dto, keycloakUser);

        if (!string.IsNullOrEmpty(dto.Password))
            UpdateCredentials(dto, keycloakUser);

        try
        {
            await _keycloakRepository.UpdateUser(_keycloakConfiguration.Realm, keycloakUser);
        }
        catch (ApiException ex) when (ex.Message.Contains("User exists with same username or email"))
        {
            throw new ConflictException(ApplicationErrorCode.ConflictUserWithSameUsernameExists);
        }

        await UpdateUserRoles(dto.Id, dto);

        var result = await _keycloakRepository.GetUser(_keycloakConfiguration.Realm, dto.Id);
        var resultDto = _mapper.Map<UserDto>(result);
        await _authorizationService.SetAuthorizationRelatedProperties(resultDto);
        return resultDto;
    }

    /// <inheritdoc />
    public async Task<long> Delete(Guid id)
    {
        if (_authorizationService.AuthorizationDisabled)
            throw new InvalidOperationException("Authorization is disabled");

        if (!_authorizationService.CanManageUser(id))
            throw new ForbiddenException(ApplicationErrorCode.ForbiddenForeignUserData);

        if (id == _authorizationService.CurrentUserId)
            throw new ConflictException(ApplicationErrorCode.ConflictUserNotAllowedToDeleteItself);

        await _keycloakRepository.DeleteUser(_keycloakConfiguration.Realm, id);
        return 1;
    }

    /// <inheritdoc />
    public async Task SetUserRelatedProperties<T>(T dto, CancellationToken cancellationToken)
        where T : class, IUserLinkedGridDto
    {
        var list = new List<T>() { dto };
        await SetUserRelatedProperties(null, list, cancellationToken);
    }

    /// <inheritdoc />
    public async Task SetUserRelatedProperties<T>(TimeSheetFilterSet filters, List<T> dtos, CancellationToken cancellationToken)
        where T : class, IUserLinkedGridDto
    {
        if (_authorizationService.AuthorizationDisabled)
            return;

        var filteredUsers = await GetFiltered(filters, cancellationToken);

        foreach (var dto in dtos)
        {
            var user = filteredUsers.FirstOrDefault(x => x.Id == dto.UserId);
            dto.UserId = user?.Id ?? AuthorizationService.DefaultUserId;
            dto.Username = user?.Username ?? AuthorizationService.DefaultUsername;
        }
    }

    private static void UpdateCredentials(UserDto dto, UserRepresentation keycloakUser)
        => keycloakUser.Credentials = new List<CredentialRepresentation> { new() {
            Type = "password",
            Temporary = true,
            Value = dto.Password,
        } };

    private async Task UpdateUserRoles(Guid userId, UserDto dto)
    {
        var client = await _keycloakRepository.GetClients(_keycloakConfiguration.Realm);
        var clientId = client.Single(x => x.ClientId == _keycloakConfiguration.ClientId).Id;

        var allClientRoles = await _keycloakRepository.GetClientRoles(_keycloakConfiguration.Realm, clientId);
        var userRoleNames = _mapper.Map<List<string>>(dto.Permissions);
        var userRoles = allClientRoles.Where(x => userRoleNames.Contains(x.Name)).ToList();

        await _keycloakRepository.DeleteClientRolesOfUser(_keycloakConfiguration.Realm, userId, clientId, allClientRoles);
        await _keycloakRepository.AddClientRolesToUser(_keycloakConfiguration.Realm, userId, clientId, userRoles);
    }
}