using AutoMapper;
using FS.Keycloak.RestApiClient.Client;
using FS.Keycloak.RestApiClient.Model;
using FS.TimeTracking.Abstractions.DTOs.Administration;
using FS.TimeTracking.Core.Exceptions;
using FS.TimeTracking.Core.Interfaces.Application.Services.Administration;
using FS.TimeTracking.Core.Interfaces.Repository.Services.Administration;
using FS.TimeTracking.Core.Models.Application.Core;
using FS.TimeTracking.Core.Models.Configuration;
using FS.TimeTracking.Core.Models.Filter;
using Microsoft.Extensions.Options;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace FS.TimeTracking.Application.Services.Administration;

/// <inheritdoc />
public class UserService : IUserService
{
    private readonly KeycloakConfiguration _configuration;
    private readonly IMapper _mapper;
    private readonly IKeycloakRepository _keycloakRepository;

    /// <summary>
    /// Initializes a new instance of the <see cref="UserService"/> class.
    /// </summary>
    /// <param name="configuration">The configuration.</param>
    /// <param name="mapper">The mapper.</param>
    /// <param name="keycloakRepository">The keycloak repository.</param>
    /// <autogeneratedoc />
    public UserService(IOptions<TimeTrackingConfiguration> configuration, IMapper mapper, IKeycloakRepository keycloakRepository)
    {
        _configuration = configuration.Value.Keycloak;
        _mapper = mapper;
        _keycloakRepository = keycloakRepository;
    }

    /// <inheritdoc />
    public async Task<UserDto> Get(Guid id, CancellationToken cancellationToken = default)
    {
        var user = await _keycloakRepository.GetUser(_configuration.Realm, id, cancellationToken);
        var client = await _keycloakRepository.GetClients(_configuration.Realm, cancellationToken);
        var clientId = client.Single(x => x.ClientId == _configuration.ClientId).Id;

        var userDto = _mapper.Map<UserDto>(user);

        var userClientRoles = await _keycloakRepository.GetClientRolesOfUser(_configuration.Realm, userDto.Id, clientId, cancellationToken);
        var userClientRoleNames = userClientRoles.Select(x => x.Name).ToList();
        userDto.Permissions = _mapper.Map<List<PermissionDto>>(userClientRoleNames);

        return userDto;
    }

    /// <inheritdoc />
    public async Task<List<UserDto>> GetFiltered(TimeSheetFilterSet filters, CancellationToken cancellationToken = default)
    {
        var users = await _keycloakRepository.GetUsers(_configuration.Realm, cancellationToken: cancellationToken);
        var userDtos = _mapper
            .Map<List<UserDto>>(users)
            .OrderBy(x => !x.Enabled)
            .ThenBy(x => x.Username)
            .ToList();

        var userFilter = filters.UserFilter.CreateFilter();
        if (userFilter != null)
            userDtos = userDtos.Where(userFilter.Compile()).ToList();

        return userDtos;
    }

    /// <inheritdoc />
    public async Task<List<UserGridDto>> GetGridFiltered(TimeSheetFilterSet filters, CancellationToken cancellationToken = default)
    {
        var users = await GetFiltered(filters, cancellationToken);
        return _mapper.Map<List<UserGridDto>>(users);
    }

    /// <inheritdoc />
    public async Task<UserGridDto> GetGridItem(Guid id, CancellationToken cancellationToken = default)
    {
        var user = await _keycloakRepository.GetUser(_configuration.Realm, id, cancellationToken);
        return _mapper.Map<UserGridDto>(user);
    }

    /// <inheritdoc />
    public async Task<UserDto> Create(UserDto dto)
    {
        var user = _mapper.Map<UserRepresentation>(dto);

        if (!string.IsNullOrEmpty(dto.Password))
            UpdateCredentials(dto, user);

        try
        {
            await _keycloakRepository.CreateUser(_configuration.Realm, user);
        }
        catch (ApiException ex) when (
            ex.Message.Contains("User exists with same username") ||
            ex.Message.Contains("User exists with same email"))
        {
            throw new ConflictException(ApplicationErrorCode.ConflictUserWithSameUsernameExists);
        }

        var keycloakUsers = await _keycloakRepository.GetUsers(_configuration.Realm);
        var keycloakUser = _mapper.Map<UserDto>(keycloakUsers.First(x => x.Username == dto.Username.ToLower()));
        await UpdateUserRoles(keycloakUser.Id, dto);

        return keycloakUser;
    }

    /// <inheritdoc />
    public async Task<UserDto> Update(UserDto dto)
    {
        var keycloakUser = await _keycloakRepository.GetUser(_configuration.Realm, dto.Id);
        _mapper.Map(dto, keycloakUser);

        if (!string.IsNullOrEmpty(dto.Password))
            UpdateCredentials(dto, keycloakUser);

        try
        {
            await _keycloakRepository.UpdateUser(_configuration.Realm, keycloakUser);
        }
        catch (ApiException ex) when (ex.Message.Contains("User exists with same username or email"))
        {
            throw new ConflictException(ApplicationErrorCode.ConflictUserWithSameUsernameExists);
        }

        await UpdateUserRoles(dto.Id, dto);

        var updatedUser = await _keycloakRepository.GetUser(_configuration.Realm, dto.Id);
        return _mapper.Map<UserDto>(updatedUser);
    }

    /// <inheritdoc />
    public async Task<long> Delete(Guid id)
    {
        await _keycloakRepository.DeleteUser(_configuration.Realm, id);
        return 1;
    }

    private static void UpdateCredentials(UserDto dto, UserRepresentation keycloakUser)
        => keycloakUser.Credentials = new List<CredentialRepresentation> { new() {
            Type = "password",
            Temporary = true,
            Value = dto.Password,
        } };

    private async Task UpdateUserRoles(Guid userId, UserDto dto)
    {
        var client = await _keycloakRepository.GetClients(_configuration.Realm);
        var clientId = client.Single(x => x.ClientId == _configuration.ClientId).Id;

        var allClientRoles = await _keycloakRepository.GetClientRoles(_configuration.Realm, clientId);
        var userRoleNames = _mapper.Map<List<string>>(dto.Permissions);
        var userRoles = allClientRoles.Where(x => userRoleNames.Contains(x.Name)).ToList();

        await _keycloakRepository.DeleteClientRolesOfUser(_configuration.Realm, userId, clientId, allClientRoles);
        await _keycloakRepository.AddClientRolesToUser(_configuration.Realm, userId, clientId, userRoles);
    }
}