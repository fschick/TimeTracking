using FS.FilterExpressionCreator.Abstractions.Extensions;
using FS.FilterExpressionCreator.Abstractions.Models;
using FS.TimeTracking.Abstractions.DTOs.Chart;
using FS.TimeTracking.Application.Extensions;
using FS.TimeTracking.Core.Extensions;
using FS.TimeTracking.Core.Interfaces.Application.Services.Chart;
using FS.TimeTracking.Core.Interfaces.Application.Services.MasterData;
using FS.TimeTracking.Core.Interfaces.Application.Services.Shared;
using FS.TimeTracking.Core.Interfaces.Repository.Services;
using FS.TimeTracking.Core.Models.Application.Chart;
using FS.TimeTracking.Core.Models.Application.MasterData;
using FS.TimeTracking.Core.Models.Filter;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace FS.TimeTracking.Application.Services.Chart;

/// <inheritdoc />
public class OrderChartService : IOrderChartService
{
    private readonly IWorkdayService _workdayService;
    private readonly ISettingService _settingService;
    private readonly IRepository _repository;

    /// <summary>
    /// Initializes a new instance of the <see cref="OrderChartService"/> class.
    /// </summary>
    /// <param name="workdayService">The workday service.</param>
    /// <param name="settingService">The setting service.</param>
    /// <param name="repository">The repository.</param>
    /// <autogeneratedoc />
    public OrderChartService(IWorkdayService workdayService, ISettingService settingService, IRepository repository)
    {
        _workdayService = workdayService;
        _settingService = settingService;
        _repository = repository;
    }

    /// <inheritdoc />
    public async Task<List<OrderWorkTimeDto>> GetWorkTimesPerOrder(TimeSheetFilterSet filters, CancellationToken cancellationToken = default)
    {
        var settings = await _settingService.GetSettings(cancellationToken);
        var filter = ChartFilter.Create(filters);
        var workedTimesPerOrder = await GetWorkedTimesPerOrder(filter, cancellationToken);
        var plannedTimesPerOrder = await GetPlannedTimesPerOrder(filter, cancellationToken);

        var totalWorkedDays = workedTimesPerOrder.Sum(x => x.WorkedDays);
        var totalPlannedDays = plannedTimesPerOrder.Sum(x => x.PlannedDays);

        var result = workedTimesPerOrder
            .CrossJoin(
                plannedTimesPerOrder,
                worked => worked.OrderId,
                planned => planned.OrderId,
                (worked, planned) =>
                {
                    if (worked == null && planned == null)
                        throw new InvalidOperationException("Planned and worked entities are null");

                    var plannedTimeSpan = worked != null
                        ? worked.PlannedStart.CreateRange(worked.PlannedEnd)
                        : planned.PlannedStart.CreateRange(planned.PlannedEnd);

                    var daysDifference = planned?.PlannedDays - (worked?.WorkedDays ?? 0);

                    return new OrderWorkTimeDto
                    {
                        OrderId = worked?.OrderId ?? planned.OrderId,
                        OrderTitle = worked?.OrderTitle ?? planned?.OrderTitle,
                        OrderNumber = worked?.OrderNumber ?? planned?.OrderNumber,
                        CustomerTitle = worked?.CustomerTitle ?? planned?.CustomerTitle,
                        TotalWorkedPercentage = totalWorkedDays != 0 ? (worked?.WorkedDays ?? 0) / totalWorkedDays : 0,
                        TotalPlannedPercentage = totalPlannedDays != 0 ? (planned?.PlannedDays ?? 0) / totalPlannedDays : null,
                        DaysWorked = worked?.WorkedDays ?? 0,
                        DaysPlanned = planned?.PlannedDays,
                        DaysDifference = daysDifference,
                        TimeWorked = worked?.WorkedTime ?? TimeSpan.Zero,
                        TimePlanned = planned?.PlannedTime,
                        TimeDifference = daysDifference.HasValue ? TimeSpan.FromHours(daysDifference.Value * settings.WorkHoursPerWorkday.TotalHours) : null,
                        BudgetWorked = worked?.WorkedBudget ?? 0,
                        BudgetPlanned = planned?.PlannedBudget,
                        BudgetDifference = planned?.PlannedBudget - (worked?.WorkedBudget ?? 0),
                        PlannedStart = plannedTimeSpan?.Start,
                        PlannedEnd = plannedTimeSpan?.End,
                        PlannedIsPartial = !filter.SelectedPeriod.Contains(plannedTimeSpan),
                        Currency = settings.Company.Currency,
                    };
                })
            .OrderBy(x => x.PlannedStart)
            .ThenBy(x => x.CustomerTitle)
            .ThenBy(x => x.OrderTitle)
            .ThenBy(x => x.OrderNumber)
            .ToList();

        return result;
    }

    /// <inheritdoc />
    public async Task<List<OrderWorkTime>> GetWorkedTimesPerOrder(ChartFilter filter, CancellationToken cancellationToken)
    {
        var settings = await _settingService.GetSettings(cancellationToken);

        var timeSheetsPerOrder = await _repository
            .GetGrouped(
                groupBy: timeSheet => new { timeSheet.OrderId, timeSheet.Order.Title, timeSheet.Order.Number },
                select: timeSheets => new
                {
                    OrderId = timeSheets.Key.OrderId.Value,
                    OrderTitle = timeSheets.Key.Title,
                    OrderNumber = timeSheets.Key.Number,
                    WorkedTime = TimeSpan.FromSeconds(timeSheets.Sum(f => (double)f.StartDateLocal.DiffSeconds(f.StartDateOffset, f.EndDateLocal, f.EndDateOffset))),
                    timeSheets.FirstOrDefault().Order.HourlyRate,
                    CustomerId = timeSheets.FirstOrDefault().Project.Customer.Id,
                    CustomerTitle = timeSheets.FirstOrDefault().Project.Customer.Title,
                    PlannedStart = timeSheets.FirstOrDefault().Order.StartDate,
                    PlannedEnd = timeSheets.FirstOrDefault().Order.DueDate,
                },
                where: new[] { filter.WorkedTimes.CreateFilter(), x => x.OrderId != null }.CombineWithConditionalAnd(),
                cancellationToken: cancellationToken
            );

        var workedTimesPerOrder = timeSheetsPerOrder
            .Select(timeSheet => new OrderWorkTime
            {
                OrderId = timeSheet.OrderId,
                OrderTitle = timeSheet.OrderTitle,
                OrderNumber = timeSheet.OrderNumber,
                WorkedDays = timeSheet.WorkedTime.TotalHours / settings.WorkHoursPerWorkday.TotalHours,
                WorkedTime = timeSheet.WorkedTime,
                WorkedBudget = timeSheet.WorkedTime.TotalHours * timeSheet.HourlyRate,
                CustomerId = timeSheet.CustomerId,
                CustomerTitle = timeSheet.CustomerTitle,
                PlannedStart = timeSheet.PlannedStart,
                PlannedEnd = timeSheet.PlannedEnd,
            })
            .ToList();

        return workedTimesPerOrder;
    }

    /// <inheritdoc />
    public async Task<List<OrderWorkTime>> GetPlannedTimesPerOrder(ChartFilter filter, CancellationToken cancellationToken)
    {
        var settings = await _settingService.GetSettings(cancellationToken);

        var orders = await _repository
            .Get(
                select: (Order x) => x,
                where: filter.PlannedTimes,
                includes: new[] { nameof(Order.Customer) },
                cancellationToken: cancellationToken
            );

        var plannedTimesPerOrder = await orders
            .SelectAsync(async order =>
            {
                var plannedTime = await GetPlannedTimeForPeriod(order, filter.SelectedPeriod);
                return new OrderWorkTime
                {
                    OrderId = order.Id,
                    OrderTitle = order.Title,
                    OrderNumber = order.Number,
                    CustomerId = order.CustomerId,
                    CustomerTitle = order.Customer.Title,
                    PlannedTime = plannedTime,
                    PlannedDays = plannedTime.TotalHours / settings.WorkHoursPerWorkday.TotalHours,
                    PlannedBudget = plannedTime.TotalHours * order.HourlyRate,
                    PlannedStart = order.StartDate,
                    PlannedEnd = order.DueDate,
                };
            })
            .ToListAsync();

        return plannedTimesPerOrder;
    }

    /// <inheritdoc />
    [ExcludeFromCodeCoverage(Justification = "Tested by TimeSheetServiceTests/TimeSheetService.GetWorkedDaysOverview")]
    public async Task<int> GetPersonalWorkdaysCount(DateTimeOffset startDate, DateTimeOffset endDate, CancellationToken cancellationToken)
    {
        var workdays = await _workdayService.GetWorkdays(startDate.Date, endDate.Date, cancellationToken);
        return workdays.PersonalWorkdays.Count;
    }

    private async Task<TimeSpan> GetPlannedTimeForPeriod(Order order, Range<DateTimeOffset> selectedPeriod)
    {
        var orderPeriod = new Range<DateTimeOffset>(order.StartDate, order.DueDate);
        var orderWorkdays = await _workdayService.GetWorkdays(orderPeriod);
        var orderWorkHours = order.HourlyRate != 0 ? order.Budget / order.HourlyRate : 0;

        var planningPeriod = orderPeriod.Intersection(selectedPeriod);
        if (planningPeriod == null)
            throw new InvalidOperationException($"Order '{order.Title}' has no planned time within selected period. Order period: {orderPeriod}, selected period: {selectedPeriod}.");

        var plannedWorkDays = await _workdayService.GetWorkdays(planningPeriod);

        var ratio = orderWorkdays.PersonalWorkdays.Count != 0
            ? plannedWorkDays.PersonalWorkdays.Count / (double)orderWorkdays.PersonalWorkdays.Count
            : 1;
        return TimeSpan.FromHours(orderWorkHours * ratio);
    }
}