using FS.FilterExpressionCreator.Abstractions.Extensions;
using FS.TimeTracking.Abstractions.DTOs.Chart;
using FS.TimeTracking.Core.Extensions;
using FS.TimeTracking.Core.Interfaces.Application.Services.Administration;
using FS.TimeTracking.Core.Interfaces.Application.Services.Chart;
using FS.TimeTracking.Core.Interfaces.Application.Services.Shared;
using FS.TimeTracking.Core.Interfaces.Repository.Services.Database;
using FS.TimeTracking.Core.Models.Application.Chart;
using FS.TimeTracking.Core.Models.Filter;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace FS.TimeTracking.Application.Services.Chart;

/// <inheritdoc />
public class ProjectChartService : IProjectChartApiService
{
    private readonly ISettingApiService _settingService;
    private readonly IFilterFactory _filterFactory;
    private readonly IDbRepository _dbRepository;

    /// <summary>
    /// Initializes a new instance of the <see cref="ProjectChartService" /> class.
    /// </summary>
    /// <param name="settingService">The setting service.</param>
    /// <param name="filterFactory">The filter factory.</param>
    /// <param name="dbRepository">The repository.</param>
    /// <autogeneratedoc />
    public ProjectChartService(ISettingApiService settingService, IFilterFactory filterFactory, IDbRepository dbRepository)
    {
        _settingService = settingService;
        _filterFactory = filterFactory;
        _dbRepository = dbRepository;
    }

    /// <inheritdoc />
    public async Task<List<ProjectWorkTimeDto>> GetWorkTimesPerProject(TimeSheetFilterSet filters, CancellationToken cancellationToken = default)
    {
        var settings = await _settingService.GetSettings(cancellationToken);
        var filter = await _filterFactory.CreateChartFilter(filters);
        var workedTimesPerProject = await GetWorkedTimesPerProject(filter, cancellationToken);

        var totalWorkedDays = workedTimesPerProject.Sum(x => x.WorkedDays);

        var result = workedTimesPerProject
            .Select(worked => new ProjectWorkTimeDto
            {
                ProjectId = worked.ProjectId,
                ProjectTitle = worked.ProjectTitle,
                ProjectHidden = worked.ProjectHidden,
                CustomerTitle = worked.CustomerTitle,
                TimeWorked = worked.WorkedTime,
                DaysWorked = worked.WorkedDays,
                TotalWorkedPercentage = totalWorkedDays != 0 ? worked.WorkedDays / totalWorkedDays : 0,
                BudgetWorked = worked.WorkedBudget,
                Currency = settings.Company.Currency,
            })
            .OrderBy(x => x.ProjectTitle)
            .ThenBy(x => x.CustomerTitle)
            .ToList();

        result = AppendCustomerToNonUniqueProjectNames(result);
        return result;
    }

    private async Task<List<ProjectWorkTime>> GetWorkedTimesPerProject(ChartFilter filter, CancellationToken cancellationToken)
    {
        var settings = await _settingService.GetSettings(cancellationToken);

        var timeSheetsPerProjectAndOrder = await _dbRepository
            .GetGrouped(
                groupBy: timeSheet => new { timeSheet.Project.Id, timeSheet.Project.Title, timeSheet.Project.Hidden, timeSheet.OrderId },
                select: timeSheets => new
                {
                    ProjectId = timeSheets.Key.Id,
                    ProjectTitle = timeSheets.Key.Title,
                    ProjectHidden = timeSheets.Key.Hidden,
                    CustomerTitle = timeSheets.FirstOrDefault().Customer.Title,
                    WorkedTime = TimeSpan.FromSeconds(timeSheets.Sum(f => (double)f.StartDateLocal.DiffSeconds(f.StartDateOffset, f.EndDateLocal, f.EndDateOffset))),
                    HourlyRate = timeSheets.Key.OrderId != null
                        ? timeSheets.Min(t => t.Order.HourlyRate)
                        : timeSheets.Min(t => t.Customer.HourlyRate),
                },
                where: new[] { x => x.ProjectId != null, filter.WorkedTimes.CreateFilter() }.CombineWithConditionalAnd(),
                cancellationToken: cancellationToken
            );

        var workedTimesPerProject = timeSheetsPerProjectAndOrder
            .GroupBy(timeSheet => new { timeSheet.ProjectId, timeSheet.ProjectTitle, timeSheet.ProjectHidden })
            .Select(timeSheets => new ProjectWorkTime
            {
                ProjectId = timeSheets.Key.ProjectId,
                ProjectTitle = timeSheets.Key.ProjectTitle,
                ProjectHidden = timeSheets.Key.ProjectHidden,
                CustomerTitle = timeSheets.First().CustomerTitle,
                WorkedTime = timeSheets.Sum(h => h.WorkedTime),
                WorkedBudget = timeSheets.Select(f => f.WorkedTime.TotalHours * f.HourlyRate).Sum(),
            })
            .ToList();

        foreach (var workTime in workedTimesPerProject)
            workTime.WorkedDays = workTime.WorkedTime.TotalHours / settings.WorkHoursPerWorkday.TotalHours;

        return workedTimesPerProject;
    }

    private static List<ProjectWorkTimeDto> AppendCustomerToNonUniqueProjectNames(IEnumerable<ProjectWorkTimeDto> projectWorkTimes)
        => projectWorkTimes
            .GroupBy(project => project.ProjectTitle)
            .SelectMany(projectNameGroup => projectNameGroup.Count() > 1 ? projectNameGroup.Select(AppendCustomerProjectName) : projectNameGroup)
            .ToList();

    private static ProjectWorkTimeDto AppendCustomerProjectName(ProjectWorkTimeDto projectWorkTime)
    {
        projectWorkTime.ProjectTitle = $"{projectWorkTime.ProjectTitle} ({projectWorkTime.CustomerTitle})";
        return projectWorkTime;
    }
}